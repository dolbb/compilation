%{
	#include <iostream>
	#include <map>
	#include <string>
	#include <vector>
	#include "parser.hpp"
	#include "output.hpp"
	#include "compiler.hpp"

	#ifndef YYERROR_VERBOSE
	#define YYERROR_VERBOSE 0 
	#endif

	using namespace std;
	using namespace output;
	
		unsigned int _breakables = 0;
	
	//example: bool isA = isVarExists(_TablesStack.back(), "a");
	bool isVarExists(const string& name);
	//example: bool isFunA = isFunExists(_FunctionsStack, "funcA");
	bool isFunExists(const string& name);
	VariableType getVariableType(string name);
	VariableType getFunctionReturnType(string name);
	vector<VariableType>& getFunctionArgsTypes(string name);
	void declareVariable(VariableType type, string name);
	void declareArgument(VariableType type, string name);
	void declareFunction(VariableType type, string name);
	void openScope();
	void closeScope();
	void closeGlobalScope();
	
	void assertIfMainUndefined();
	void assert_unexpected_break();
	void assertIfDefined(string name);
	void assertIfUndefined(string name);
	bool isNumericType(VariableType type);
	void assertIfNotBool(VariableType type);
	void assertIfNotNumeric(VariableType type);
	void assertIfTypeNotMatch(VariableType type1, VariableType type2);
	bool isNumericType(VariableType type);
	void assertUnexpectedBreak();
	void assertIfByteTooLarge(string value);
	void assertIfDefault();
	void assertFuncUndefined(string name);
	
	bool is_assignable(VariableType src, VariableType dst);
	bool is_assignable(vector<VariableType> srcs, vector<VariableType> dsts);
	FunctionEntry& getFunction(string name); //@@@@@@@@
	
	//void declarePrint() ;
	//void declarePrinti() ;

	
	extern int yylex();
	int yyerror(const char * message);
	extern int yylineno;
	
	

%}

%expect 1

%token RETURN

%token LPAREN RPAREN
%token LBRACE RBRACE
%token SC
%token COLON

%right ASSIGN
%left OR
%left AND 
%left RELOP
%left RELEQ
%left PLUS MINUS
%left MULT DIV
%right NOT

%token INT
%token BYTE
%token VOID
%token COMMA

%token TRUE FALSE

%token IF 
%token ELSE

%token WHILE
%token BREAK
%token BOOL
%token SWITCH
%token CASE
%token DEFAULT

%token NUM
%token ID
%token STRING
%token B



%% // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Program : MarkerStart Funcs {
	assertIfMainUndefined();
	CODE.bpatch($1.main_list, getFunction("main").implementation);	
	CODE.printDataBuffer();
	CODE.printCodeBuffer();
}
;
Funcs : FuncDecl Funcs
| //epsilon
;
FuncDecl : FuncHeader {openScope(); } FormalsParen LBRACE Statements RBRACE {
	emit_callee_retvoid();
	closeScope(); 
}
;
FuncHeader:  Type ID {
	string name = $2.name;
	assertIfDefined(name);
	declareFunction($1.type,name); 
	CODE.emit("\n #________________________\n ########## Declaring Function " + name + "##########"); // $$$$$$$$$$$
	emit_callee_begin();
}
| VOID ID {
	assertIfDefined($2.name);
	declareFunction(VAR_TYPE_VOID, $2.name); 
	CODE.emit("\n #________________________\n ########## Declaring Function " + $2.name + "##########"); // $$$$$$$$$$$
	emit_callee_begin();
}
;

FormalsParen: LPAREN FormalsList RPAREN
| LPAREN RPAREN
;

FormalsList : FormalDecl
| FormalDecl COMMA FormalsList
;

FormalDecl : Type ID {
	assertIfDefined($2.name);
	declareArgument($1.type,$2.name);
}
;


VarDecl : Type ID {
	assertIfDefined($2.name); 	
	$$.type = $1.type;
	$$.name = $2.name; 
	emit_stack_new($$.name); 
}
;

Statements : Statements Statement {
	 $$.break_list = CODE.merge($1.break_list, $2.break_list); 
}
| Statement {$$ = $1;} 
;

Statement : LBRACE {openScope(); } Statements RBRACE {
	closeScope(); 
	$$ = $3; 
}
| VarDecl SC {
	declareVariable($1.type,$1.name); // emit_stack_new is called inside VarDecl
	CODE.emit("# assign default value:");
	compile_constantNumber(); 
	//puts the register value of last line into the variable in memory
	compile_assign($1.name); 
	
}
| VarDecl ASSIGN Exp SC {
	if(!is_assignable($3.type, $1.type)){
		errorMismatch(yylineno);
		exit(1);
	}
	declareVariable($1.type,$1.name); // emit_stack_new is called inside VarDecl
	compile_assign($1.name, $3);
	
}
| ID ASSIGN Exp SC {
	assertIfUndefined($1.name);
	if(!is_assignable($3.type, getVariableType($1.name))){
		errorMismatch(yylineno);
		exit(1);
	}

	compile_assign($1.name, $3);
}
| Call SC {
	$$.type = $1.type;
} 
| RETURN SC {

	if(getReturnType() != VAR_TYPE_VOID){
		errorMismatch(yylineno);
		exit(1);
	 }
	
	emit_callee_retvoid ();		
} 
| RETURN Exp SC {
	if(!is_assignable($2.type, getReturnType())){
		   errorMismatch(yylineno
		   );
		   exit(1);
	 }

	
		emit_compute_bool($2); // if not bool doing nothing
		emit_callee_retval ();	
} 
| IfStatement %prec IF {							
	$$ = $1;	
	CODE.emit("# There is no \"else\"!");
	CODE.bpatch($$.false_list, CODE.next());	
}
| IfStatement ELSE ElseStatementMarker {openScope();} Statement %prec ELSE {
	closeScope();
	CODE.bpatch($$.false_list, $3.label);	
	CODE.bpatch(CODE.makelist($3.bufferIndex), CODE.next());
	$$.break_list = CODE.merge($1.break_list, $5.break_list);
}	

|   WHILE {_breakables++; } WhileCondMarker LPAREN Exp RPAREN  {assertIfNotBool($5.type /* = Exp*/); openScope();} WhileStatementMarker Statement {
	closeScope();
	_breakables--;
	emit_while($3.label, $5 /* =Exp*/, $8.label, $9 /* =Statement*/);
}
| BREAK SC {
	my_assert(_breakables >= 0);
	if(_breakables == 0){
		assertUnexpectedBreak();
	}
	$$ = comp_break();
}

| SWITCH  SwitchExpMarker LPAREN Exp RPAREN  {assertIfNotNumeric( $4.type /* = Exp*/); openScope(); _breakables++; }  SwitchCasesMarker LBRACE CaseList RBRACE SC {
	closeScope();
	_breakables --;
	
	emit_switch($9 /* = CaseList */, $7.bufferIndex /* = SwitchCasesMarker */); 
}
;

IfStatement : IfCondMarker IF LPAREN Exp RPAREN  IfStatementMarker {assertIfNotBool($4.type); openScope(); }  Statement  {
	closeScope(); 
	CODE.bpatch($4.true_list, $6.label); // = Exp, IfStatementMarker
	$$ = $8; // = Statement
	$$.false_list = $4.false_list; // = Exp
	
}
;

SwitchExpMarker: {
	CODE.emit("# Switch :: Expression Evaluation:");
}
;

SwitchCasesMarker: {
	CODE.emit("# Switch :: Jump to Coparison of expression to cases:");
	reg_ReduceAndGetName(); // Exp not relevant inside the list
	$$.bufferIndex = compile_jump();
	CODE.emit("# Switch :: CaseList block:");
}
;

WhileCondMarker: {
	$$.label = CODE.next(); 
	CODE.emit("# While :: Condition Evaluation:");
}
;

WhileStatementMarker: {
	$$.label = CODE.next(); 
	CODE.emit("# While :: statement:");
}
;

IfCondMarker: {
	CODE.emit("# If :: Condition Evaluation:");
}
;

IfStatementMarker: {
	$$.label = CODE.next(); 
	CODE.emit("# If :: statement:");
}
;

ElseStatementMarker: {
	$$.bufferIndex = compile_jump();
	$$.label = CODE.next(); 
	CODE.emit("# Else:");
}



MarkerStart: { 
	$$.main_list = emit_main();
	declarePrint();
	emit_print(); 
	declarePrinti();
	emit_printi();
	emit_divError();
};

CaseList : CaseList CaseStatement 

{
	$$ = $1;
	$$.break_list = CODE.merge($$.break_list, $2.break_list);
	if($2.default_label == ""){ 						// CaseStatement is of "case" type
		$$.case_list.push_back($2.case_list.back());
	} else {											// CaseStatement is of "default" type
		$$.default_label = $2.default_label;
	}
}  
| CaseStatement  {$$ = $1;} 
;
CaseStatement : CaseDec Statements	 

 {
	 $$ = $2;
	 $$.case_list = $1.case_list;
	 $$.default_label = $1.default_label;
} 

| CaseDec {$$ = $1;} 
;
CaseDec : CASE NUM COLON {
	$$ = comp_case($2.num);
}
| CASE NUM B COLON {
	$$ = comp_case($2.num, true);
}
| DEFAULT COLON {
	assertIfDefault();  
	$$ = comp_default(); 
}
;
Call : ID ExpParen {
	string name = $1.name;
	assertFuncUndefined(name); 
	FunctionEntry& func = getFunction(name);
	$$.type = func.returnType;
	if( !is_assignable($2.argTypes, func.argTypes)){
		errorPrototypeMismatch(yylineno, name, func.argTypesNames);
		exit(1);
	}
	
	emit_caller(name); 		
} 
;
ExpParen : LPAREN ExpList RPAREN {$$ = $2;}
| LPAREN RPAREN
;
ExpList : Exp {$$.argTypes.push_back($1.type); emit_compute_bool($1);} 
| ExpList COMMA Exp {$$ = $1; $$.argTypes.push_back($3.type); emit_compute_bool($3);} 
;
Type : INT {$$.type = VAR_TYPE_INT; } 
| BYTE {$$.type = VAR_TYPE_BYTE; } 
| BOOL {$$.type = VAR_TYPE_BOOL; } 
;
Exp : LPAREN Exp RPAREN {
	 $$ = $2;
}
| Exp PLUS Exp{
	assertIfNotNumeric($1.type);
	assertIfNotNumeric($3.type);
	if($1.type == VAR_TYPE_INT || $3.type == VAR_TYPE_INT){
		$$.type = VAR_TYPE_INT;
		 compile_plus();		
	}
	else{
		$$.type = VAR_TYPE_BYTE;
		 compile_plus(true);		
	}
	
}
| Exp MINUS Exp{
	assertIfNotNumeric($1.type);
	assertIfNotNumeric($3.type);
	
	if($1.type == VAR_TYPE_INT || $3.type == VAR_TYPE_INT){
		$$.type = VAR_TYPE_INT;
		 compile_minus();		
	}
	else{
		$$.type = VAR_TYPE_BYTE;
		 compile_minus(true);		
	}
}
| Exp MULT Exp{
	assertIfNotNumeric($1.type);
	assertIfNotNumeric($3.type);
	
	if($1.type == VAR_TYPE_INT || $3.type == VAR_TYPE_INT){
		$$.type = VAR_TYPE_INT;
		 compile_mul();		
	}
	else{
		$$.type = VAR_TYPE_BYTE;
		 compile_mul(true);		
	}
}
| Exp DIV Exp{
	assertIfNotNumeric($1.type);
	assertIfNotNumeric($3.type);
	
	if($1.type == VAR_TYPE_INT || $3.type == VAR_TYPE_INT){
		$$.type = VAR_TYPE_INT;
		 compile_div();		
	}
	else{
		$$.type = VAR_TYPE_BYTE;
		 compile_div(true);		
	}
}
| ID {
	assertIfUndefined($1.name);
	$$.type = getVariableType($1.name);
	compile_read_var($1.name);	
	
	if($$.type == VAR_TYPE_BOOL){
		$$ = compile_registerBoolJump();
	}

}
| Call {
	emit_caller_retval();
	$$.type = $1.type;
	if($$.type == VAR_TYPE_BOOL){
		$$ = compile_registerBoolJump();
	}
} 		
| NUM { $$.type = VAR_TYPE_INT;  compile_constantNumber($1.num); }
| NUM B {
	assertIfByteTooLarge($1.name); // תזכורת: עם כל הגועל שבדבר, ה"שם" של מספר הוא הכתיבה שלו כמחרוזת
	$$ = $1;
	$$.type = VAR_TYPE_BYTE; 
	 compile_constantNumber($1.num); 
}
| STRING { $$.type = VAR_TYPE_STRING;  compile_constString($1.str); }
| TRUE {   $$ = compile_constantBoolJump(true); }
| FALSE { $$ = compile_constantBoolJump(false); }
| NOT Exp {
	assertIfNotBool($2.type);
	$$ = compile_not($2); 
}
| Exp AND Next Exp {
	assertIfNotBool($1.type);
	assertIfNotBool($4.type);
	$$ = compile_and($1, $4, $3.label); 
}
| Exp OR Next Exp{
	assertIfNotBool($1.type);
	assertIfNotBool($4.type);
	$$ = compile_or($1,$4, $3.label);
}
| Exp RELOP Exp{
	assertIfNotNumeric($1.type);
	assertIfNotNumeric($3.type);
	$$ = compile_relop($2.relop);
}
| Exp RELEQ Exp {
	assertIfNotNumeric($1.type);
	assertIfNotNumeric($3.type);
	$$ = compile_relop($2.relop);
}
;
Next : {
	$$.label = CODE.next();
}
;

%% // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

void assertIfMainUndefined() {

	if(getFunctionReturnType("main") == VAR_TYPE_VOID && getFunctionArgsTypes("main").size() == 0){ //covers the case of undefined
		return;
	}
	errorMainMissing();
	exit(1);
}

void assert_unexpected_break() {
	errorUnexpectedBreak(yylineno);
	exit(1);
}

void assertIfDefined(string name) {
	if (isVarExists(name) || (isFunExists(name))) {
		output::errorDef(yylineno, name.c_str());
		exit(1);
	}
}

void assertIfUndefined(string name) {
	if (getVariableType(name) == VAR_TYPE_UNDEFINED) {
		errorUndef(yylineno, name.c_str());
		exit(1);
	}
}


void assertFuncUndefined(string name) { 
	if (getFunctionReturnType(name) == VAR_TYPE_UNDEFINED) {
		errorUndefFunc(yylineno, name.c_str());
		exit(1);
	}
}


void assertIfNotBool(VariableType type) {
	if (type != VAR_TYPE_BOOL) {
		errorMismatch(yylineno);
		exit(1);
	}
}

void assertIfNotNumeric(VariableType type) {
	if (!isNumericType(type)) {
		errorMismatch(yylineno);
		exit(1);
	}
}


void assertIfTypeNotMatch(VariableType type1, VariableType type2) {
	if (type1 == VAR_TYPE_UNDEFINED || type2 == VAR_TYPE_UNDEFINED
		|| ((type1 == VAR_TYPE_BOOL) != (type2 == VAR_TYPE_BOOL))
		|| (isNumericType(type1) != isNumericType(type2))) {

		errorMismatch(yylineno);
		exit(1);
	}
}

bool isNumericType(VariableType type) {
	return type == VAR_TYPE_BYTE
		|| type == VAR_TYPE_INT;
}

void assertUnexpectedBreak(){
	errorUnexpectedBreak(yylineno);
	exit(1);
}

void assertIfByteTooLarge(string value) {
	int i = atoi(value.c_str());
	if (i > MAX_BYTE )
	{
		errorByteTooLarge(yylineno, value);
		exit(1);
	}
}

void assertIfDefault() {
	if (isDefault()){
		output::errorTooManyDefaults(yylineno);
		exit(1);
	}
	else{
		setIsDefault();
	}
}


bool is_assignable(VariableType src, VariableType dst){
	 if(src == dst) 
		 return true;
	 if(src == VAR_TYPE_BYTE && dst == VAR_TYPE_INT) 
		 return true;
	 return false;
}
 
 bool is_assignable(vector<VariableType> srcs, vector<VariableType> dsts){
	 int len = dsts.size();
	 if(srcs.size() != len) 
		 return false;
	 for(int i=0; i<len; i++){
		 if(!is_assignable(srcs[i], dsts[i]))
			 return false;
	 }
	 return true;
 }

 int main()
{
	//yydebug = 1;
	return yyparse();
}


int yyerror(const char * message)
{
	errorSyn(yylineno);
	exit(1);
}
